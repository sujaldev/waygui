import inspect
import textwrap
from pathlib import Path
from typing import List, Tuple
from xml.etree import ElementTree
from xml.etree.ElementTree import Element

from helpers import *
from primitives import *

CONFLICTING_BUILTIN_NAMES = ("id", "format")
MAX_TEXT_WIDTH = 120
ARG_MAP = {
    "int": Int32,
    "uint": UInt32,
    "fixed": Fixed,
    "object": ObjID,
    "new_id": NewID,
    "string": String,
    "fd": Fd,
    "array": Array,
}


def generate_arg_type_annotation(type_: str) -> str:
    type_ = ARG_MAP[type_]
    constructor_signature = list(inspect.signature(type_.__init__).parameters.values())
    first_param_annotation = constructor_signature[1].annotation
    return f"{type_.__name__} | {first_param_annotation.__name__}"


def generate_method_header(tag: Element, return_type: str = None, is_event: bool = False) -> str:
    func_name = tag.attrib['name']
    if is_event:
        func_name = "on_" + func_name

    header = f"def {func_name}(%s):"

    if return_type:
        header = "%s -> %s:" % (header.rstrip(":"), return_type)

    signature = [
        arg_tag.attrib["name"] +
        (": " if arg_tag.attrib["name"] not in CONFLICTING_BUILTIN_NAMES else "_: ") +
        generate_arg_type_annotation(arg_tag.attrib["type"])
        for arg_tag in tag.iter("arg")
    ]
    signature.insert(0, "self")

    signature_str = ", ".join(signature)

    if (4 + len(header) - 2 + len(signature_str)) > MAX_TEXT_WIDTH:
        signature_str = "\n" + textwrap.indent(format_list(signature, MAX_TEXT_WIDTH - 12), " " * 8) + "\n"

    return header % signature_str


def generate_request_method(tag: Element, opcode: int) -> str:
    header = generate_method_header(tag, "bytes")
    signature = [
        (name := arg_tag.attrib["name"]) +
        ("_" if name in CONFLICTING_BUILTIN_NAMES else "")
        for arg_tag in tag.iter("arg")
    ]
    signature.insert(0, str(opcode))

    signature_str = ", ".join(signature)

    body = "return self.serialize_request(%s)"

    if 8 + (len(body) - 2) + len(signature_str) > MAX_TEXT_WIDTH:
        signature_str = format_list(signature, MAX_TEXT_WIDTH - 8)

    body = body % signature_str

    return header + "\n" + textwrap.indent(body, " " * 4) + "\n\n"


def generate_event_method(tag: Element) -> str:
    header = generate_method_header(tag, is_event=True)
    body = textwrap.indent("raise NotImplementedError", " " * 4)

    return header + "\n" + body + "\n\n"


def generate_interface(root_tag: Element) -> Tuple[str, str]:
    code = ""

    protocol_name = root_tag.attrib["name"]
    for interface_tag in root_tag.iter("interface"):
        class_name = snake_to_pascal_case(interface_tag.attrib["name"])
        code += f"class {class_name}(WLObject):\n"

        body_is_empty = True

        events = []

        event_methods = ""
        for event_tag in interface_tag.iter("event"):
            events.append('"on_' + event_tag.attrib["name"] + '"')

            event_methods += textwrap.indent(generate_event_method(event_tag), " " * 4)

        if events:
            body_is_empty = False
            events_str = ", ".join(events)
            event_code = "EVENTS = [%s]"

            if 4 + len(event_code % events_str) > MAX_TEXT_WIDTH:
                events_str = "\n" + textwrap.indent(format_list(events, MAX_TEXT_WIDTH - 8), " " * 4) + "\n"

            code += textwrap.indent(
                f"EVENTS = [{events_str}]", " " * 4
            ) + "\n\n"

            code += event_methods

        request_code = ""
        for opcode, request_tag in enumerate(interface_tag.iter("request")):
            # type_ = request_tag.attrib.get("type", None)
            request_code += "@request\n" + generate_request_method(request_tag, opcode)

        if request_code:
            body_is_empty = False
            code += textwrap.indent(request_code, " " * 4)

        if body_is_empty:
            code += textwrap.indent("pass\n", " " * 4)

        code += "\n"

    return protocol_name, code.rstrip("\n") + "\n"


def scanner(paths: List, output_dir: Path | str):
    template = textwrap.dedent("""
    # This file is auto-generated by scanner.py

    from ..primitives import *
    from ..client_core import *


    %s
    """).strip()

    if not isinstance(output_dir, Path):
        output_dir = Path(output_dir).resolve()

    if not output_dir.exists():
        output_dir.mkdir(parents=True, exist_ok=True)

    for path in paths:
        xml = ElementTree.parse(path)
        protocol_name, code = generate_interface(xml.getroot())
        code = template % code
        with open(output_dir / (protocol_name + ".py"), "w") as file:
            file.write(code)


if __name__ == "__main__":
    scanner([
        "/usr/share/wayland/wayland.xml",
        "/usr/share/wayland-protocols/stable/xdg-shell/xdg-shell.xml",
        "/usr/share/wayland-protocols/unstable/xdg-decoration/xdg-decoration-unstable-v1.xml"
    ], "./protocols")
